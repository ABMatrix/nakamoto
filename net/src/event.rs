//! Events generated by the peer-to-peer system.
use std::sync::{Arc, Mutex};
use std::time;

use crossbeam_channel as chan;

pub use chan::RecvTimeoutError;

/// An event publish/subscribe channel.
///
/// Takes events of type `E`, and maps them to events of type `T` which
/// are forwarded to all subscribers.
pub struct Broadcast<E, T> {
    /// Emits events of type `T` to subscribers.
    emitter: Emitter<T>,
    /// Takes an event of type `E` and emits zero or more events of type `T` to subscribers.
    forward: Box<dyn FnMut(E, &Emitter<T>) + Send + Sync>,
}

impl<E, T: Clone> Broadcast<E, T> {
    /// Broadcast an event to all subscribers.
    pub fn broadcast(&mut self, event: E) {
        (self.forward)(event, &self.emitter.clone());
    }
}

/// Publishes events to subscribers.
#[derive(Clone)]
pub struct Emitter<T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
}

impl<T> Default for Emitter<T> {
    fn default() -> Self {
        Self {
            subscribers: Default::default(),
        }
    }
}

impl<T: Clone> Emitter<T> {
    /// Emit an event to all subscribers and drop subscribers who can't receive it.
    pub fn emit(&self, event: T) {
        self.subscribers
            .lock()
            .unwrap()
            .retain(|s| s.try_send(event.clone()).is_ok());
    }

    /// Drop all subscribers.
    pub fn close(self) {
        self.subscribers.lock().unwrap().clear();
    }

    /// Create a subscriber from this emitter.
    pub fn subscriber(&self) -> Subscriber<T> {
        Subscriber {
            subscribers: self.subscribers.clone(),
        }
    }
}

/// Subscribes to events.
#[derive(Clone)]
pub struct Subscriber<T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
}

impl<T: Clone> Subscriber<T> {
    /// Add a subscription to receive broadcast events.
    pub fn subscribe(&self) -> chan::Receiver<T> {
        let (sender, receiver) = chan::unbounded();
        let mut subs = self.subscribers.lock().unwrap();
        subs.push(sender);

        receiver
    }
}

/// Create a new broadcast channel.
pub fn broadcast<E, T: Clone>(
    forward: impl FnMut(E, &Emitter<T>) + Send + Sync + 'static,
) -> (Broadcast<E, T>, Subscriber<T>) {
    let emitter = Emitter::default();
    let subscriber = emitter.subscriber();
    (
        Broadcast {
            emitter,
            forward: Box::new(forward),
        },
        subscriber,
    )
}

/// Listen to an event feed, and wait for the given function to return something,
/// or timeout if the specified amount of time has elapsed.
pub fn wait<E, F, T>(
    events: &chan::Receiver<E>,
    mut f: F,
    timeout: time::Duration,
) -> Result<T, chan::RecvTimeoutError>
where
    F: FnMut(E) -> Option<T>,
{
    let start = time::Instant::now();

    loop {
        if let Some(timeout) = timeout.checked_sub(start.elapsed()) {
            match events.recv_timeout(timeout) {
                Ok(event) => {
                    if let Some(t) = f(event) {
                        return Ok(t);
                    }
                }
                Err(err @ chan::RecvTimeoutError::Disconnected) => {
                    return Err(err);
                }
                Err(chan::RecvTimeoutError::Timeout) => {
                    // Keep trying until our timeout reaches zero.
                    continue;
                }
            }
        } else {
            return Err(chan::RecvTimeoutError::Timeout);
        }
    }
}

/// Any type that is able to publish events.
pub trait Publisher<E>: Send + Sync {
    /// Publish an event.
    fn publish(&mut self, event: E);
}

impl<E, T: Clone + Send + Sync> Publisher<E> for Broadcast<E, T> {
    /// Publish a message to all subscribers.
    fn publish(&mut self, event: E) {
        self.broadcast(event)
    }
}
